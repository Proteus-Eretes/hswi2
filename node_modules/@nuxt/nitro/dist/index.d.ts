import { NestedHooks, Hookable } from 'hookable';
import { Preset } from 'unenv';
import { Nuxt, NuxtHooks, NuxtOptions } from '@nuxt/kit';
import { PluginVisualizerOptions } from 'rollup-plugin-visualizer';
import { NodeFileTraceOptions } from '@vercel/nft';
import * as h3 from 'h3';
import { Middleware } from 'h3';
import { InputOptions, OutputOptions } from 'rollup';
import { Loader } from 'esbuild';
import { FilterPattern } from '@rollup/pluginutils';
import { Worker } from 'worker_threads';
import { ListenOptions, Listener } from 'listhen';
import * as fs from 'fs';
import fsExtra from 'fs-extra';

interface NodeExternalsOptions {
    inline?: string[];
    external?: string[];
    outDir?: string;
    trace?: boolean;
    traceOptions?: NodeFileTraceOptions;
    moduleDirectories?: string[];
}

interface StorageOptions {
    mounts: {
        [path: string]: {
            driver: 'fs' | 'http' | 'memory';
            driverOptions?: Record<string, any>;
        };
    };
}

interface AssetOptions {
    inline: Boolean;
    dirs: {
        [assetdir: string]: {
            dir: string;
            meta?: boolean;
        };
    };
}

interface ServerMiddleware {
    route: string;
    /**
     * @deprecated use route
     */
    path?: string;
    handle?: Middleware | string;
    /**
     * @deprecated use handle
     */
    handler?: Middleware | string;
    lazy?: boolean;
    promisify?: boolean;
}
declare function scanMiddleware(serverDir: string, onChange?: (results: ServerMiddleware[], event: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', file: string) => void): Promise<ServerMiddleware[]>;
declare function resolveMiddleware(nuxt: Nuxt): {
    middleware: ServerMiddleware[];
    legacyMiddleware: ServerMiddleware[];
};

declare type RollupConfig = InputOptions & {
    output: OutputOptions;
};

declare type Options = {
    include?: FilterPattern;
    exclude?: FilterPattern;
    sourceMap?: boolean;
    minify?: boolean;
    target?: string | string[];
    jsxFactory?: string;
    jsxFragment?: string;
    define?: {
        [k: string]: string;
    };
    /**
     * Use this tsconfig file instead
     * Disable it by setting to `false`
     */
    tsconfig?: string | false;
    /**
     * Map extension to esbuild loader
     * Note that each entry (the extension) needs to start with a dot
     */
    loaders?: {
        [ext: string]: Loader | false;
    };
};

interface NitroHooks {
    'nitro:document': (htmlTemplate: {
        src: string;
        contents: string;
        dst: string;
    }) => void;
    'nitro:rollup:before': (context: NitroContext) => void | Promise<void>;
    'nitro:compiled': (context: NitroContext) => void;
    'close': () => void;
}
interface NitroContext {
    alias: Record<string, string>;
    timing: boolean;
    inlineDynamicImports: boolean;
    minify: boolean;
    sourceMap: boolean;
    externals: boolean | NodeExternalsOptions;
    analyze: false | PluginVisualizerOptions;
    entry: string;
    node: boolean;
    preset: string;
    rollupConfig?: RollupConfig;
    esbuild?: {
        options?: Options;
    };
    experiments?: {
        wasm?: boolean;
    };
    moduleSideEffects: string[];
    renderer: string;
    serveStatic: boolean;
    middleware: ServerMiddleware[];
    scannedMiddleware: ServerMiddleware[];
    hooks: NestedHooks<NitroHooks>;
    nuxtHooks: NestedHooks<NuxtHooks>;
    ignore: string[];
    env: Preset;
    vfs: Record<string, string>;
    output: {
        dir: string;
        serverDir: string;
        publicDir: string;
    };
    storage: StorageOptions;
    assets: AssetOptions;
    _nuxt: {
        majorVersion: number;
        dev: boolean;
        ssr: boolean;
        rootDir: string;
        srcDir: string;
        buildDir: string;
        generateDir: string;
        publicDir: string;
        serverDir: string;
        routerBase: string;
        publicPath: string;
        isStatic: boolean;
        fullStatic: boolean;
        staticAssets: any;
        modulesDir: string[];
        runtimeConfig: {
            public: any;
            private: any;
        };
    };
    _internal: {
        runtimeDir: string;
        hooks: Hookable<NitroHooks>;
    };
}
declare type DeepPartial<T> = T extends Record<string, any> ? {
    [P in keyof T]?: DeepPartial<T[P]> | T[P];
} : T;
interface NitroInput extends DeepPartial<NitroContext> {
}
declare type NitroPreset = NitroInput | ((input: NitroInput) => NitroInput);
declare function getNitroContext(nuxtOptions: NuxtOptions, input: NitroInput): NitroContext;

declare function prepare(nitroContext: NitroContext): Promise<void>;
declare function generate(nitroContext: NitroContext): Promise<void>;
declare function build(nitroContext: NitroContext): Promise<void | {
    entry: string;
}>;

interface NitroWorker {
    worker: Worker;
    address: string;
}
declare function createDevServer(nitroContext: NitroContext): {
    reload: () => Promise<void>;
    listen: (port: ListenOptions['port'], opts?: Partial<ListenOptions>) => Promise<Listener>;
    app: h3.App;
    close: () => Promise<void>;
    watch: () => void;
    setLegacyMiddleware: (input: Middleware) => void;
    setDevMiddleware: (input: Middleware) => void;
};

declare const wpfs: {
    join: (...paths: string[]) => string;
    copy(src: string, dest: string, options?: fsExtra.CopyOptions): Promise<void>;
    copy(src: string, dest: string, callback: (err: Error) => void): void;
    copy(src: string, dest: string, options: fsExtra.CopyOptions, callback: (err: Error) => void): void;
    copySync(src: string, dest: string, options?: fsExtra.CopyOptionsSync): void;
    copyFile(src: string, dest: string, flags?: number): Promise<void>;
    copyFile(src: string, dest: string, callback: (err: Error) => void): void;
    copyFile(src: string, dest: string, flags: number, callback: (err: Error) => void): void;
    move(src: string, dest: string, options?: fsExtra.MoveOptions): Promise<void>;
    move(src: string, dest: string, callback: (err: Error) => void): void;
    move(src: string, dest: string, options: fsExtra.MoveOptions, callback: (err: Error) => void): void;
    moveSync(src: string, dest: string, options?: fsExtra.MoveOptions): void;
    createFile(file: string): Promise<void>;
    createFile(file: string, callback: (err: Error) => void): void;
    createFileSync(file: string): void;
    createSymlink(src: string, dest: string, type: fsExtra.SymlinkType): Promise<void>;
    createSymlink(src: string, dest: string, type: fsExtra.SymlinkType, callback?: (err: Error) => void): void;
    createSymlinkSync(src: string, dest: string, type: fsExtra.SymlinkType): void;
    ensureDir(path: string, options?: number | fsExtra.EnsureOptions): Promise<void>;
    ensureDir(path: string, callback?: (err: Error) => void): void;
    ensureDir(path: string, options?: number | fsExtra.EnsureOptions, callback?: (err: Error) => void): void;
    ensureDirSync(path: string, options?: number | fsExtra.EnsureOptions): void;
    mkdirs(dir: string): Promise<void>;
    mkdirs(dir: string, callback: (err: Error) => void): void;
    mkdirp(dir: string): Promise<void>;
    mkdirp(dir: string, callback: (err: Error) => void): void;
    mkdirsSync(dir: string): void;
    mkdirpSync(dir: string): void;
    outputFile(file: string, data: any, options?: string | fsExtra.WriteFileOptions): Promise<void>;
    outputFile(file: string, data: any, callback: (err: Error) => void): void;
    outputFile(file: string, data: any, options: string | fsExtra.WriteFileOptions, callback: (err: Error) => void): void;
    outputFileSync(file: string, data: any, options?: string | fsExtra.WriteFileOptions): void;
    readJson(file: string, options?: string | fsExtra.ReadOptions): Promise<any>;
    readJson(file: string, callback: (err: Error, jsonObject: any) => void): void;
    readJson(file: string, options: string | fsExtra.ReadOptions, callback: (err: Error, jsonObject: any) => void): void;
    readJSON(file: string, options?: string | fsExtra.ReadOptions): Promise<any>;
    readJSON(file: string, callback: (err: Error, jsonObject: any) => void): void;
    readJSON(file: string, options: string | fsExtra.ReadOptions, callback: (err: Error, jsonObject: any) => void): void;
    readJsonSync(file: string, options?: string | fsExtra.ReadOptions): any;
    readJSONSync(file: string, options?: string | fsExtra.ReadOptions): any;
    remove(dir: string, callback: (err: Error) => void): void;
    remove(dir: string, callback?: (err: Error) => void): Promise<void>;
    removeSync(dir: string): void;
    outputJSON(file: string, data: any, options?: string | fsExtra.WriteOptions): Promise<void>;
    outputJSON(file: string, data: any, options: string | fsExtra.WriteOptions, callback: (err: Error) => void): void;
    outputJSON(file: string, data: any, callback: (err: Error) => void): void;
    outputJson(file: string, data: any, options?: string | fsExtra.WriteOptions): Promise<void>;
    outputJson(file: string, data: any, options: string | fsExtra.WriteOptions, callback: (err: Error) => void): void;
    outputJson(file: string, data: any, callback: (err: Error) => void): void;
    outputJsonSync(file: string, data: any, options?: string | fsExtra.WriteOptions): void;
    outputJSONSync(file: string, data: any, options?: string | fsExtra.WriteOptions): void;
    writeJSON(file: string, object: any, options?: string | fsExtra.WriteOptions): Promise<void>;
    writeJSON(file: string, object: any, callback: (err: Error) => void): void;
    writeJSON(file: string, object: any, options: string | fsExtra.WriteOptions, callback: (err: Error) => void): void;
    writeJson(file: string, object: any, options?: string | fsExtra.WriteOptions): Promise<void>;
    writeJson(file: string, object: any, callback: (err: Error) => void): void;
    writeJson(file: string, object: any, options: string | fsExtra.WriteOptions, callback: (err: Error) => void): void;
    writeJsonSync(file: string, object: any, options?: string | fsExtra.WriteOptions): void;
    writeJSONSync(file: string, object: any, options?: string | fsExtra.WriteOptions): void;
    ensureFile(path: string): Promise<void>;
    ensureFile(path: string, callback: (err: Error) => void): void;
    ensureFileSync(path: string): void;
    ensureLink(src: string, dest: string): Promise<void>;
    ensureLink(src: string, dest: string, callback: (err: Error) => void): void;
    ensureLinkSync(src: string, dest: string): void;
    ensureSymlink(src: string, dest: string, type?: fsExtra.SymlinkType): Promise<void>;
    ensureSymlink(src: string, dest: string, type: fsExtra.SymlinkType, callback: (err: Error) => void): void;
    ensureSymlink(src: string, dest: string, callback: (err: Error) => void): void;
    ensureSymlinkSync(src: string, dest: string, type?: fsExtra.SymlinkType): void;
    emptyDir(path: string): Promise<void>;
    emptyDir(path: string, callback: (err: Error) => void): void;
    emptyDirSync(path: string): void;
    pathExists(path: string): Promise<boolean>;
    pathExists(path: string, callback: (err: Error, exists: boolean) => void): void;
    pathExistsSync(path: string): boolean;
    access(path: fsExtra.PathLike, callback: (err: NodeJS.ErrnoException) => void): void;
    access(path: fsExtra.PathLike, mode: number, callback: (err: NodeJS.ErrnoException) => void): void;
    access(path: fsExtra.PathLike, mode?: number): Promise<void>;
    appendFile(file: number | fsExtra.PathLike, data: any, options: {
        encoding?: string;
        mode?: string | number;
        flag?: string;
    }, callback: (err: NodeJS.ErrnoException) => void): void;
    appendFile(file: number | fsExtra.PathLike, data: any, callback: (err: NodeJS.ErrnoException) => void): void;
    appendFile(file: number | fsExtra.PathLike, data: any, options?: string | {
        encoding?: string;
        mode?: string | number;
        flag?: string;
    }): Promise<void>;
    chmod(path: fsExtra.PathLike, mode: fsExtra.Mode, callback: (err: NodeJS.ErrnoException) => void): void;
    chmod(path: fsExtra.PathLike, mode: fsExtra.Mode): Promise<void>;
    chown(path: fsExtra.PathLike, uid: number, gid: number): Promise<void>;
    chown(path: fsExtra.PathLike, uid: number, gid: number, callback: (err: NodeJS.ErrnoException) => void): void;
    close(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;
    close(fd: number): Promise<void>;
    fchmod(fd: number, mode: fsExtra.Mode, callback: (err: NodeJS.ErrnoException) => void): void;
    fchmod(fd: number, mode: fsExtra.Mode): Promise<void>;
    fchown(fd: number, uid: number, gid: number, callback: (err: NodeJS.ErrnoException) => void): void;
    fchown(fd: number, uid: number, gid: number): Promise<void>;
    fdatasync(fd: number, callback: () => void): void;
    fdatasync(fd: number): Promise<void>;
    fstat(fd: number, callback: (err: NodeJS.ErrnoException, stats: fsExtra.Stats) => any): void;
    fstat(fd: number): Promise<fsExtra.Stats>;
    fsync(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;
    fsync(fd: number): Promise<void>;
    ftruncate(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;
    ftruncate(fd: number, len: number, callback: (err: NodeJS.ErrnoException) => void): void;
    ftruncate(fd: number, len?: number): Promise<void>;
    futimes(fd: number, atime: number, mtime: number, callback: (err: NodeJS.ErrnoException) => void): void;
    futimes(fd: number, atime: Date, mtime: Date, callback: (err: NodeJS.ErrnoException) => void): void;
    futimes(fd: number, atime: number, mtime: number): Promise<void>;
    futimes(fd: number, atime: Date, mtime: Date): Promise<void>;
    lchown(path: fsExtra.PathLike, uid: number, gid: number, callback: (err: NodeJS.ErrnoException) => void): void;
    lchown(path: fsExtra.PathLike, uid: number, gid: number): Promise<void>;
    link(existingPath: fsExtra.PathLike, newPath: fsExtra.PathLike, callback: (err: NodeJS.ErrnoException) => void): void;
    link(existingPath: fsExtra.PathLike, newPath: fsExtra.PathLike): Promise<void>;
    lstat(path: fsExtra.PathLike, callback: (err: NodeJS.ErrnoException, stats: fsExtra.Stats) => any): void;
    lstat(path: fsExtra.PathLike): Promise<fsExtra.Stats>;
    mkdir(path: fsExtra.PathLike, callback: (err: NodeJS.ErrnoException) => void): void;
    mkdir(path: fsExtra.PathLike, options: fsExtra.Mode | fsExtra.MakeDirectoryOptions, callback: (err: NodeJS.ErrnoException) => void): void;
    mkdir(path: fsExtra.PathLike, options?: fsExtra.Mode | fsExtra.MakeDirectoryOptions): Promise<void>;
    mkdirSync(path: fsExtra.PathLike, options?: fsExtra.Mode | fsExtra.MakeDirectoryOptions): void;
    open(path: fsExtra.PathLike, flags: string | number, callback: (err: NodeJS.ErrnoException, fd: number) => void): void;
    open(path: fsExtra.PathLike, flags: string | number, mode: fsExtra.Mode, callback: (err: NodeJS.ErrnoException, fd: number) => void): void;
    open(path: fsExtra.PathLike, flags: string | number, mode?: fsExtra.Mode): Promise<number>;
    opendir(path: string, cb: (err: NodeJS.ErrnoException, dir: fsExtra.Dir) => void): void;
    opendir(path: string, options: fsExtra.OpenDirOptions, cb: (err: NodeJS.ErrnoException, dir: fsExtra.Dir) => void): void;
    opendir(path: string, options?: fsExtra.OpenDirOptions): Promise<fsExtra.Dir>;
    read<TBuffer extends fsExtra.ArrayBufferView>(fd: number, buffer: TBuffer, offset: number, length: number, position: number, callback: (err: NodeJS.ErrnoException, bytesRead: number, buffer: TBuffer) => void): void;
    read<TBuffer_1 extends fsExtra.ArrayBufferView>(fd: number, buffer: TBuffer_1, offset: number, length: number, position: number): Promise<{
        bytesRead: number;
        buffer: TBuffer_1;
    }>;
    readFile(file: number | fsExtra.PathLike, callback: (err: NodeJS.ErrnoException, data: Buffer) => void): void;
    readFile(file: number | fsExtra.PathLike, encoding: string, callback: (err: NodeJS.ErrnoException, data: string) => void): void;
    readFile(file: number | fsExtra.PathLike, options: {
        flag?: string;
    } | {
        encoding: string;
        flag?: string;
    }, callback: (err: NodeJS.ErrnoException, data: Buffer) => void): void;
    readFile(file: number | fsExtra.PathLike, options: {
        flag?: string;
    } | {
        encoding: string;
        flag?: string;
    }): Promise<string>;
    readFile(file: number | fsExtra.PathLike, encoding: string): Promise<string>;
    readFile(file: number | fsExtra.PathLike): Promise<Buffer>;
    readdir(path: fsExtra.PathLike, callback: (err: NodeJS.ErrnoException, files: string[]) => void): void;
    readdir(path: fsExtra.PathLike, options: "buffer" | {
        encoding: "buffer";
        withFileTypes?: false;
    }): Promise<Buffer[]>;
    readdir(path: fsExtra.PathLike, options?: string | {
        encoding: string;
        withFileTypes?: false;
    }): Promise<string[]>;
    readdir(path: fsExtra.PathLike, options?: {
        encoding?: string;
        withFileTypes?: false;
    }): Promise<string[] | Buffer[]>;
    readdir(path: fsExtra.PathLike, options: {
        encoding?: string;
        withFileTypes: true;
    }): Promise<fsExtra.Dirent[]>;
    readlink(path: fsExtra.PathLike, callback: (err: NodeJS.ErrnoException, linkString: string) => any): void;
    readlink(path: fsExtra.PathLike): Promise<string>;
    realpath: typeof fsExtra.realpath;
    rename(oldPath: fsExtra.PathLike, newPath: fsExtra.PathLike, callback: (err: NodeJS.ErrnoException) => void): void;
    rename(oldPath: fsExtra.PathLike, newPath: fsExtra.PathLike): Promise<void>;
    rm(path: fsExtra.PathLike, options?: {
        force?: boolean;
        maxRetries?: number;
        recursive?: boolean;
        retryDelay?: number;
    }): Promise<void>;
    rmdir(path: fsExtra.PathLike, callback: (err: NodeJS.ErrnoException) => void): void;
    rmdir(path: fsExtra.PathLike, options?: fsExtra.RmDirOptions): Promise<void>;
    stat(path: fsExtra.PathLike, callback: (err: NodeJS.ErrnoException, stats: fsExtra.Stats) => any): void;
    stat(path: fsExtra.PathLike): Promise<fsExtra.Stats>;
    symlink(target: fsExtra.PathLike, path: fsExtra.PathLike, type: fsExtra.SymlinkType, callback: (err: NodeJS.ErrnoException) => void): void;
    symlink(target: fsExtra.PathLike, path: fsExtra.PathLike, callback: (err: NodeJS.ErrnoException) => void): void;
    symlink(target: fsExtra.PathLike, path: fsExtra.PathLike, type?: fsExtra.SymlinkType): Promise<void>;
    truncate(path: fsExtra.PathLike, callback: (err: NodeJS.ErrnoException) => void): void;
    truncate(path: fsExtra.PathLike, len: number, callback: (err: NodeJS.ErrnoException) => void): void;
    truncate(path: fsExtra.PathLike, len?: number): Promise<void>;
    unlink(path: fsExtra.PathLike, callback: (err: NodeJS.ErrnoException) => void): void;
    unlink(path: fsExtra.PathLike): Promise<void>;
    utimes(path: fsExtra.PathLike, atime: number, mtime: number, callback: (err: NodeJS.ErrnoException) => void): void;
    utimes(path: fsExtra.PathLike, atime: Date, mtime: Date, callback: (err: NodeJS.ErrnoException) => void): void;
    utimes(path: fsExtra.PathLike, atime: number, mtime: number): Promise<void>;
    utimes(path: fsExtra.PathLike, atime: Date, mtime: Date): Promise<void>;
    write<TBuffer_2 extends fsExtra.ArrayBufferView>(fd: number, buffer: TBuffer_2, offset: number, length: number, position: number, callback: (err: NodeJS.ErrnoException, written: number, buffer: TBuffer_2) => void): void;
    write<TBuffer_3 extends fsExtra.ArrayBufferView>(fd: number, buffer: TBuffer_3, offset: number, length: number, callback: (err: NodeJS.ErrnoException, written: number, buffer: TBuffer_3) => void): void;
    write(fd: number, data: any, callback: (err: NodeJS.ErrnoException, written: number, str: string) => void): void;
    write(fd: number, data: any, offset: number, callback: (err: NodeJS.ErrnoException, written: number, str: string) => void): void;
    write(fd: number, data: any, offset: number, encoding: string, callback: (err: NodeJS.ErrnoException, written: number, str: string) => void): void;
    write<TBuffer_4 extends fsExtra.ArrayBufferView>(fd: number, buffer: TBuffer_4, offset?: number, length?: number, position?: number): Promise<{
        bytesWritten: number;
        buffer: TBuffer_4;
    }>;
    write(fd: number, data: any, offset?: number, encoding?: string): Promise<{
        bytesWritten: number;
        buffer: string;
    }>;
    writeFile(file: number | fsExtra.PathLike, data: any, callback: (err: NodeJS.ErrnoException) => void): void;
    writeFile(file: number | fsExtra.PathLike, data: any, options?: string | fsExtra.WriteFileOptions): Promise<void>;
    writeFile(file: number | fsExtra.PathLike, data: any, options: string | fsExtra.WriteFileOptions, callback: (err: NodeJS.ErrnoException) => void): void;
    writev(fd: number, buffers: NodeJS.ArrayBufferView[], position: number, cb: (err: NodeJS.ErrnoException, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void): void;
    writev(fd: number, buffers: NodeJS.ArrayBufferView[], cb: (err: NodeJS.ErrnoException, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void): void;
    writev(fd: number, buffers: NodeJS.ArrayBufferView[], position?: number): Promise<fsExtra.WritevResult>;
    mkdtemp(prefix: string): Promise<string>;
    mkdtemp(prefix: string, callback: (err: NodeJS.ErrnoException, folder: string) => void): void;
    createLink: typeof fsExtra.ensureLink;
    createLinkSync: typeof fsExtra.ensureLinkSync;
    emptydir: typeof fsExtra.emptyDir;
    emptydirSync: typeof fsExtra.emptyDirSync;
    renameSync(oldPath: fsExtra.PathLike, newPath: fsExtra.PathLike): void;
    truncateSync(path: fsExtra.PathLike, len?: number): void;
    ftruncateSync(fd: number, len?: number): void;
    chownSync(path: fsExtra.PathLike, uid: number, gid: number): void;
    fchownSync(fd: number, uid: number, gid: number): void;
    lchownSync(path: fsExtra.PathLike, uid: number, gid: number): void;
    lutimes: typeof fsExtra.lutimes;
    lutimesSync(path: fsExtra.PathLike, atime: string | number | Date, mtime: string | number | Date): void;
    chmodSync(path: fsExtra.PathLike, mode: fs.Mode): void;
    fchmodSync(fd: number, mode: fs.Mode): void;
    lchmod: typeof fsExtra.lchmod;
    lchmodSync(path: fsExtra.PathLike, mode: fs.Mode): void;
    statSync(path: fsExtra.PathLike, options?: fsExtra.StatOptions & {
        bigint?: false;
    }): fsExtra.Stats;
    statSync(path: fsExtra.PathLike, options: fsExtra.StatOptions & {
        bigint: true;
    }): fsExtra.BigIntStats;
    statSync(path: fsExtra.PathLike, options?: fsExtra.StatOptions): fsExtra.Stats | fsExtra.BigIntStats;
    fstatSync(fd: number, options?: fsExtra.StatOptions & {
        bigint?: false;
    }): fsExtra.Stats;
    fstatSync(fd: number, options: fsExtra.StatOptions & {
        bigint: true;
    }): fsExtra.BigIntStats;
    fstatSync(fd: number, options?: fsExtra.StatOptions): fsExtra.Stats | fsExtra.BigIntStats;
    lstatSync(path: fsExtra.PathLike, options?: fsExtra.StatOptions & {
        bigint?: false;
    }): fsExtra.Stats;
    lstatSync(path: fsExtra.PathLike, options: fsExtra.StatOptions & {
        bigint: true;
    }): fsExtra.BigIntStats;
    lstatSync(path: fsExtra.PathLike, options?: fsExtra.StatOptions): fsExtra.Stats | fsExtra.BigIntStats;
    linkSync(existingPath: fsExtra.PathLike, newPath: fsExtra.PathLike): void;
    symlinkSync(target: fsExtra.PathLike, path: fsExtra.PathLike, type?: fs.symlink.Type): void;
    readlinkSync(path: fsExtra.PathLike, options?: BufferEncoding | fsExtra.BaseEncodingOptions): string;
    readlinkSync(path: fsExtra.PathLike, options: fsExtra.BufferEncodingOption): Buffer;
    readlinkSync(path: fsExtra.PathLike, options?: string | fsExtra.BaseEncodingOptions): string | Buffer;
    realpathSync: typeof fsExtra.realpathSync;
    unlinkSync(path: fsExtra.PathLike): void;
    rmdirSync(path: fsExtra.PathLike, options?: fsExtra.RmDirOptions): void;
    rmSync(path: fsExtra.PathLike, options?: fsExtra.RmOptions): void;
    mkdtempSync(prefix: string, options?: BufferEncoding | fsExtra.BaseEncodingOptions): string;
    mkdtempSync(prefix: string, options: fsExtra.BufferEncodingOption): Buffer;
    mkdtempSync(prefix: string, options?: string | fsExtra.BaseEncodingOptions): string | Buffer;
    readdirSync(path: fsExtra.PathLike, options?: BufferEncoding | {
        encoding: BufferEncoding;
        withFileTypes?: false;
    }): string[];
    readdirSync(path: fsExtra.PathLike, options: "buffer" | {
        encoding: "buffer";
        withFileTypes?: false;
    }): Buffer[];
    readdirSync(path: fsExtra.PathLike, options?: BufferEncoding | (fsExtra.BaseEncodingOptions & {
        withFileTypes?: false;
    })): string[] | Buffer[];
    readdirSync(path: fsExtra.PathLike, options: fsExtra.BaseEncodingOptions & {
        withFileTypes: true;
    }): fsExtra.Dirent[];
    closeSync(fd: number): void;
    openSync(path: fsExtra.PathLike, flags: fsExtra.OpenMode, mode?: fs.Mode): number;
    utimesSync(path: fsExtra.PathLike, atime: string | number | Date, mtime: string | number | Date): void;
    futimesSync(fd: number, atime: string | number | Date, mtime: string | number | Date): void;
    fsyncSync(fd: number): void;
    writeSync(fd: number, buffer: NodeJS.ArrayBufferView, offset?: number, length?: number, position?: number): number;
    writeSync(fd: number, string: string, position?: number, encoding?: BufferEncoding): number;
    readSync(fd: number, buffer: NodeJS.ArrayBufferView, offset: number, length: number, position: number): number;
    readSync(fd: number, buffer: NodeJS.ArrayBufferView, opts?: fsExtra.ReadSyncOptions): number;
    readFileSync(path: number | fsExtra.PathLike, options?: {
        encoding?: null;
        flag?: string;
    }): Buffer;
    readFileSync(path: number | fsExtra.PathLike, options: BufferEncoding | {
        encoding: BufferEncoding;
        flag?: string;
    }): string;
    readFileSync(path: number | fsExtra.PathLike, options?: BufferEncoding | (fsExtra.BaseEncodingOptions & {
        flag?: string;
    })): string | Buffer;
    writeFileSync(path: number | fsExtra.PathLike, data: string | NodeJS.ArrayBufferView, options?: fs.WriteFileOptions): void;
    appendFileSync(file: number | fsExtra.PathLike, data: string | Uint8Array, options?: fs.WriteFileOptions): void;
    watchFile(filename: fsExtra.PathLike, options: {
        persistent?: boolean;
        interval?: number;
    }, listener: (curr: fsExtra.Stats, prev: fsExtra.Stats) => void): void;
    watchFile(filename: fsExtra.PathLike, listener: (curr: fsExtra.Stats, prev: fsExtra.Stats) => void): void;
    unwatchFile(filename: fsExtra.PathLike, listener?: (curr: fsExtra.Stats, prev: fsExtra.Stats) => void): void;
    watch(filename: fsExtra.PathLike, options: BufferEncoding | {
        encoding?: BufferEncoding;
        persistent?: boolean;
        recursive?: boolean;
    }, listener?: (event: "change" | "rename", filename: string) => void): fsExtra.FSWatcher;
    watch(filename: fsExtra.PathLike, options: "buffer" | {
        encoding: "buffer";
        persistent?: boolean;
        recursive?: boolean;
    }, listener?: (event: "change" | "rename", filename: Buffer) => void): fsExtra.FSWatcher;
    watch(filename: fsExtra.PathLike, options: string | {
        encoding?: BufferEncoding;
        persistent?: boolean;
        recursive?: boolean;
    }, listener?: (event: "change" | "rename", filename: string | Buffer) => void): fsExtra.FSWatcher;
    watch(filename: fsExtra.PathLike, listener?: (event: "change" | "rename", filename: string) => any): fsExtra.FSWatcher;
    exists: typeof fsExtra.exists;
    existsSync(path: fsExtra.PathLike): boolean;
    accessSync(path: fsExtra.PathLike, mode?: number): void;
    createReadStream(path: fsExtra.PathLike, options?: BufferEncoding | {
        flags?: string;
        encoding?: BufferEncoding;
        fd?: number;
        mode?: number;
        autoClose?: boolean;
        emitClose?: boolean;
        start?: number;
        end?: number;
        highWaterMark?: number;
    }): fsExtra.ReadStream;
    createWriteStream(path: fsExtra.PathLike, options?: BufferEncoding | {
        flags?: string;
        encoding?: BufferEncoding;
        fd?: number;
        mode?: number;
        autoClose?: boolean;
        emitClose?: boolean;
        start?: number;
        highWaterMark?: number;
    }): fsExtra.WriteStream;
    fdatasyncSync(fd: number): void;
    copyFileSync(src: fsExtra.PathLike, dest: fsExtra.PathLike, flags?: number): void;
    writevSync(fd: number, buffers: readonly NodeJS.ArrayBufferView[], position?: number): number;
    readv: typeof fsExtra.readv;
    readvSync(fd: number, buffers: readonly NodeJS.ArrayBufferView[], position?: number): number;
    opendirSync(path: fsExtra.PathLike, options?: fsExtra.OpenDirOptions): fsExtra.Dir;
    promises: typeof fsExtra.promises;
    Stats: typeof fsExtra.Stats;
    Dirent: typeof fsExtra.Dirent;
    Dir: typeof fsExtra.Dir;
    ReadStream: typeof fsExtra.ReadStream;
    WriteStream: typeof fsExtra.WriteStream;
    constants: typeof fsExtra.constants;
    BigIntStats: typeof fsExtra.BigIntStats;
};

export { NitroContext, NitroHooks, NitroInput, NitroPreset, NitroWorker, ServerMiddleware, build, createDevServer, generate, getNitroContext, prepare, resolveMiddleware, scanMiddleware, wpfs };
