import { existsSync, readdirSync, promises, lstatSync } from 'fs';
import { join, normalize, resolve, dirname, basename, parse, extname, relative } from 'pathe';
import defu from 'defu';
import { applyDefaults } from 'untyped';
import * as rc from 'rc9';
import { pathToFileURL } from 'url';
import { interopDefault } from 'mlly';
import jiti from 'jiti';
import { hasProtocol, isRelative, joinURL, withTrailingSlash, normalizeURL } from 'ufo';
import { isDevelopment, isCI, isTest } from 'std-env';
import createRequire from 'create-require';
import { pascalCase, kebabCase, camelCase } from 'scule';
import dotenv from 'dotenv';
import { getContext } from 'unctx';
import { resolvePackageJSON, readPackageJSON } from 'pkg-types';
import consola from 'consola';
import globby from 'globby';
import lodashTemplate from 'lodash.template';
import hash from 'hash-sum';
import satisfies from 'semver/functions/satisfies.js';

const _require = jiti(process.cwd(), { interopDefault: true });
function isNodeModules(id) {
  return /[/\\]node_modules[/\\]/.test(id);
}
function clearRequireCache(id) {
  if (isNodeModules(id)) {
    return;
  }
  const entry = getRequireCacheItem(id);
  if (!entry) {
    delete _require.cache[id];
    return;
  }
  if (entry.parent) {
    entry.parent.children = entry.parent.children.filter((e) => e.id !== id);
  }
  for (const child of entry.children) {
    clearRequireCache(child.id);
  }
  delete _require.cache[id];
}
function scanRequireTree(id, files = new Set()) {
  if (isNodeModules(id) || files.has(id)) {
    return files;
  }
  const entry = getRequireCacheItem(id);
  if (!entry) {
    files.add(id);
    return files;
  }
  files.add(entry.id);
  for (const child of entry.children) {
    scanRequireTree(child.id, files);
  }
  return files;
}
function getRequireCacheItem(id) {
  try {
    return _require.cache[id];
  } catch (e) {
  }
}
function requireModulePkg(id, opts = {}) {
  return requireModule(join(id, "package.json"), opts);
}
function resolveModule(id, opts = {}) {
  return normalize(_require.resolve(id, {
    paths: [].concat(global.__NUXT_PREPATHS__, opts.paths, process.cwd(), global.__NUXT_PATHS__).filter(Boolean)
  }));
}
function tryResolveModule(path, opts = {}) {
  try {
    return resolveModule(path, opts);
  } catch (error) {
    if (error.code !== "MODULE_NOT_FOUND") {
      throw error;
    }
  }
}
function requireModule(id, opts = {}) {
  const resolvedPath = resolveModule(id, opts);
  if (opts.clearCache && !isNodeModules(id)) {
    clearRequireCache(resolvedPath);
  }
  const requiredModule = _require(resolvedPath);
  return requiredModule;
}
function importModule(id, opts = {}) {
  const resolvedPath = resolveModule(id, opts);
  if (opts.interopDefault !== false) {
    return import(pathToFileURL(resolvedPath).href).then(interopDefault);
  }
  return import(pathToFileURL(resolvedPath).href);
}
function tryImportModule(id, opts = {}) {
  try {
    return importModule(id, opts).catch(() => void 0);
  } catch {
  }
}
function tryRequireModule(id, opts = {}) {
  try {
    return requireModule(id, opts);
  } catch (e) {
  }
}

const _app = {
  vue: {
    config: {
      silent: { $resolve: (val, get) => val ?? !get("dev") },
      performance: { $resolve: (val, get) => val ?? get("dev") }
    },
    compilerOptions: {}
  },
  app: {
    $resolve: (val, get) => {
      const useCDN = hasProtocol(get("build.publicPath"), true) && !get("dev");
      const isRelativePublicPath = isRelative(get("build.publicPath"));
      return defu(val, {
        basePath: get("router.base"),
        assetsPath: isRelativePublicPath ? get("build.publicPath") : useCDN ? "/" : joinURL(get("router.base"), get("build.publicPath")),
        cdnURL: useCDN ? get("build.publicPath") : null
      });
    }
  },
  appTemplatePath: {
    $resolve: (val, get) => {
      if (val) {
        return resolve(get("srcDir"), val);
      }
      if (existsSync(join(get("srcDir"), "app.html"))) {
        return join(get("srcDir"), "app.html");
      }
      return resolve(get("buildDir"), "views/app.template.html");
    }
  },
  store: {
    $resolve: (val, get) => val !== false && existsSync(join(get("srcDir"), get("dir.store"))) && readdirSync(join(get("srcDir"), get("dir.store"))).find((filename) => filename !== "README.md" && filename[0] !== ".")
  },
  vueMeta: null,
  head: {
    meta: [],
    link: [],
    style: [],
    script: []
  },
  meta: {
    meta: [],
    link: [],
    style: [],
    script: []
  },
  fetch: {
    server: true,
    client: true
  },
  plugins: [],
  extendPlugins: null,
  css: [],
  layouts: {},
  ErrorPage: null,
  loading: {
    color: "black",
    failedColor: "red",
    height: "2px",
    throttle: 200,
    duration: 5e3,
    continuous: false,
    rtl: false,
    css: true
  },
  loadingIndicator: {
    $resolve: (val, get) => {
      val = typeof val === "string" ? { name: val } : val;
      return defu(val, {
        name: "default",
        color: get("loading.color") || "#D3D3D3",
        color2: "#F5F5F5",
        background: get("manifest") && get("manifest.theme_color") || "white",
        dev: get("dev"),
        loading: get("messages.loading")
      });
    }
  },
  pageTransition: {
    $resolve: (val, get) => {
      val = typeof val === "string" ? { name: val } : val;
      return defu(val, {
        name: "page",
        mode: "out-in",
        appear: get("render.ssr") === false || Boolean(val),
        appearClass: "appear",
        appearActiveClass: "appear-active",
        appearToClass: "appear-to"
      });
    }
  },
  layoutTransition: {
    $resolve: (val) => {
      val = typeof val === "string" ? { name: val } : val;
      return defu(val, {
        name: "layout",
        mode: "out-in"
      });
    }
  },
  features: {
    store: true,
    layouts: true,
    meta: true,
    middleware: true,
    transitions: true,
    deprecations: true,
    validate: true,
    useAsyncData: true,
    fetch: true,
    clientOnline: true,
    clientPrefetch: true,
    componentAliases: true,
    componentClientOnly: true
  }
};

const _common = {
  rootDir: {
    $resolve: (val) => typeof val === "string" ? resolve(val) : process.cwd()
  },
  srcDir: {
    $resolve: (val, get) => resolve(get("rootDir"), val || ".")
  },
  buildDir: {
    $resolve: (val, get) => resolve(get("rootDir"), val || ".nuxt")
  },
  dev: Boolean(isDevelopment),
  test: Boolean(isDevelopment),
  debug: {
    $resolve: (val, get) => val ?? get("dev")
  },
  env: {
    $default: {},
    $resolve: (val) => {
      val = { ...val };
      for (const key in process.env) {
        if (key.startsWith("NUXT_ENV_")) {
          val[key] = process.env[key];
        }
      }
      return val;
    }
  },
  createRequire: {
    $resolve: (val) => {
      val = process.env.NUXT_CREATE_REQUIRE || val || (typeof jest !== "undefined" ? "native" : "jiti");
      if (val === "jiti") {
        return (p) => jiti(typeof p === "string" ? p : p.filename);
      }
      if (val === "native") {
        return (p) => createRequire(typeof p === "string" ? p : p.filename);
      }
      return val;
    }
  },
  target: {
    $resolve: (val) => ["server", "static"].includes(val) ? val : "server"
  },
  ssr: true,
  mode: {
    $resolve: (val, get) => val || (get("ssr") ? "spa" : "universal"),
    $schema: { deprecated: "`mode` option is deprecated" }
  },
  modern: void 0,
  modules: [],
  buildModules: [],
  _modules: [],
  globalName: {
    $resolve: (val) => typeof val === "string" && /^[a-zA-Z]+$/.test(val) ? val.toLocaleLowerCase() : "nuxt"
  },
  globals: {
    id: (globalName) => `__${globalName}`,
    nuxt: (globalName) => `$${globalName}`,
    context: (globalName) => `__${globalName.toUpperCase()}__`,
    pluginPrefix: (globalName) => globalName,
    readyCallback: (globalName) => `on${pascalCase(globalName)}Ready`,
    loadedCallback: (globalName) => `_on${pascalCase(globalName)}Loaded`
  },
  serverMiddleware: {
    $resolve: (val) => {
      if (!val) {
        return [];
      }
      if (!Array.isArray(val)) {
        return Object.entries(val).map(([path, handler]) => ({ path, handler }));
      }
      return val;
    }
  },
  modulesDir: {
    $default: ["node_modules"],
    $resolve: (val, get) => [].concat(val.map((dir) => resolve(get("rootDir"), dir)), resolve(process.cwd(), "node_modules"))
  },
  dir: {
    assets: "assets",
    app: "app",
    layouts: "layouts",
    middleware: "middleware",
    pages: "pages",
    public: {
      $resolve: (val, get) => val || get("dir.static") || "public"
    },
    static: {
      $schema: { deprecated: "use `dir.public` option instead" },
      $resolve: (val, get) => val || get("dir.public") || "public"
    },
    store: "store"
  },
  extensions: {
    $resolve: (val) => [".js", ".jsx", ".mjs", ".ts", ".tsx", ".vue"].concat(val).filter(Boolean)
  },
  styleExtensions: [".css", ".pcss", ".postcss", ".styl", ".stylus", ".scss", ".sass", ".less"],
  alias: {
    $resolve: (val, get) => ({
      "~~": get("rootDir"),
      "@@": get("rootDir"),
      "~": get("srcDir"),
      "@": get("srcDir"),
      [get("dir.assets")]: join(get("srcDir"), get("dir.assets")),
      [get("dir.static")]: join(get("srcDir", get("dir.static"))),
      ...val
    })
  },
  ignoreOptions: void 0,
  ignorePrefix: "-",
  ignore: {
    $resolve: (val, get) => [
      "**/*.test.*",
      "**/*.spec.*",
      get("ignorePrefix") && `**/${get("ignorePrefix")}*.*`
    ].concat(val).filter(Boolean)
  },
  watch: {
    $resolve: (val, get) => {
      const rootDir = get("rootDir");
      return Array.from(new Set([].concat(val, get("_nuxtConfigFiles")).filter(Boolean).map((p) => resolve(rootDir, p))));
    }
  },
  watchers: {
    rewatchOnRawEvents: void 0,
    webpack: {
      aggregateTimeout: 1e3
    },
    chokidar: {
      ignoreInitial: true
    }
  },
  editor: void 0,
  hooks: null,
  privateRuntimeConfig: {},
  publicRuntimeConfig: {
    $resolve: (val, get) => defu(val, { app: get("app") })
  }
};

const _internal = {
  _majorVersion: 2,
  _legacyGenerate: false,
  _start: false,
  _build: false,
  _generate: false,
  _cli: false,
  _requiredModules: {},
  _nuxtConfigFile: void 0,
  _nuxtConfigFiles: [],
  appDir: ""
};

const build = {
  quiet: Boolean(isCI || isTest),
  analyze: false,
  profile: process.argv.includes("--profile"),
  extractCSS: false,
  cssSourceMap: {
    $resolve: (val, get) => val ?? get("dev")
  },
  ssr: void 0,
  parallel: {
    $resolve: (val, get) => get("build.extractCSS") ? false : Boolean(val)
  },
  cache: false,
  standalone: false,
  publicPath: {
    $resolve: (val, get) => {
      if (hasProtocol(val, true) && get("dev")) {
        val = null;
      }
      return (val || "/_nuxt/").replace(/([^/])$/, "$1/");
    }
  },
  serverURLPolyfill: "url",
  filenames: {
    app: ({ isDev, isModern }) => isDev ? `[name]${isModern ? ".modern" : ""}.js` : `[contenthash:7]${isModern ? ".modern" : ""}.js`,
    chunk: ({ isDev, isModern }) => isDev ? `[name]${isModern ? ".modern" : ""}.js` : `[contenthash:7]${isModern ? ".modern" : ""}.js`,
    css: ({ isDev }) => isDev ? "[name].css" : "css/[contenthash:7].css",
    img: ({ isDev }) => isDev ? "[path][name].[ext]" : "img/[name].[contenthash:7].[ext]",
    font: ({ isDev }) => isDev ? "[path][name].[ext]" : "fonts/[name].[contenthash:7].[ext]",
    video: ({ isDev }) => isDev ? "[path][name].[ext]" : "videos/[name].[contenthash:7].[ext]"
  },
  loaders: {
    $resolve: (val, get) => {
      const styleLoaders = [
        "css",
        "cssModules",
        "less",
        "sass",
        "scss",
        "stylus",
        "vueStyle"
      ];
      for (const name of styleLoaders) {
        const loader = val[name];
        if (loader && loader.sourceMap === void 0) {
          loader.sourceMap = Boolean(get("build.cssSourceMap"));
        }
      }
      return val;
    },
    file: { esModule: false },
    fontUrl: { esModule: false, limit: 1e3 },
    imgUrl: { esModule: false, limit: 1e3 },
    pugPlain: {},
    vue: {
      productionMode: { $resolve: (val, get) => val ?? !get("dev") },
      transformAssetUrls: {
        video: "src",
        source: "src",
        object: "src",
        embed: "src"
      },
      compilerOptions: { $resolve: (val, get) => val ?? get("vue.compilerOptions") }
    },
    css: {
      importLoaders: 0,
      esModule: false
    },
    cssModules: {
      importLoaders: 0,
      esModule: false,
      modules: {
        localIdentName: "[local]_[hash:base64:5]"
      }
    },
    less: {},
    sass: {
      sassOptions: {
        indentedSyntax: true
      }
    },
    scss: {},
    stylus: {},
    vueStyle: {}
  },
  styleResources: {},
  plugins: [],
  terser: {},
  hardSource: false,
  aggressiveCodeRemoval: false,
  optimizeCSS: {
    $resolve: (val, get) => val ?? (get("build.extractCSS") ? {} : false)
  },
  optimization: {
    runtimeChunk: "single",
    minimize: { $resolve: (val, get) => val ?? !get("dev") },
    minimizer: void 0,
    splitChunks: {
      chunks: "all",
      automaticNameDelimiter: "/",
      cacheGroups: {}
    }
  },
  splitChunks: {
    layouts: false,
    pages: true,
    commons: true
  },
  corejs: "auto",
  babel: {
    configFile: false,
    babelrc: false,
    plugins: [],
    presets: {},
    cacheDirectory: {
      $resolve: (val, get) => val ?? get("dev")
    }
  },
  transpile: {
    $resolve: (val) => [].concat(val).filter(Boolean)
  },
  postcss: {
    execute: void 0,
    postcssOptions: {
      config: void 0,
      plugins: void 0
    },
    sourceMap: void 0,
    implementation: void 0,
    order: ""
  },
  html: {
    minify: {
      collapseBooleanAttributes: true,
      decodeEntities: true,
      minifyCSS: true,
      minifyJS: true,
      processConditionalComments: true,
      removeEmptyAttributes: true,
      removeRedundantAttributes: true,
      trimCustomFragments: true,
      useShortDoctype: true
    }
  },
  template: void 0,
  templates: [],
  watch: [],
  devMiddleware: {
    stats: "none"
  },
  hotMiddleware: {},
  vendor: {
    $meta: {
      deprecated: "vendor has been deprecated since nuxt 2"
    }
  },
  stats: {
    $resolve: (val, get) => val === "none" || get("build.quiet") ? false : val,
    excludeAssets: [
      /.map$/,
      /index\..+\.html$/,
      /vue-ssr-(client|modern)-manifest.json/
    ]
  },
  friendlyErrors: true,
  additionalExtensions: [],
  warningIgnoreFilters: [],
  followSymlinks: false
};

const messages = {
  loading: "Loading...",
  error_404: "This page could not be found",
  server_error: "Server error",
  nuxtjs: "Nuxt",
  back_to_home: "Back to the home page",
  server_error_details: "An error occurred in the application and your page could not be served. If you are the application owner, check your logs for details.",
  client_error: "Error",
  client_error_details: "An error occurred while rendering the page. Check developer tools console for details."
};

const render = {
  bundleRenderer: {
    shouldPrefetch: () => false,
    shouldPreload: (_fileWithoutQuery, asType) => ["script", "style"].includes(asType),
    runInNewContext: { $resolve: (val, get) => val ?? get("dev") }
  },
  crossorigin: void 0,
  resourceHints: true,
  ssr: void 0,
  ssrLog: { $resolve: (val, get) => get("dev") ? Boolean(val) : false },
  http2: {
    push: false,
    shouldPush: null,
    pushAssets: null
  },
  static: {
    prefix: true
  },
  compressor: {
    threshold: 0
  },
  etag: {
    hash: false,
    weak: false
  },
  csp: {
    $resolve: (val, get) => {
      if (!val) {
        return false;
      }
      return {
        hashAlgorithm: "sha256",
        allowedSources: void 0,
        policies: void 0,
        addMeta: Boolean(get("target") === "static"),
        unsafeInlineCompatibility: false,
        reportOnly: get("debug"),
        ...val
      };
    }
  },
  dist: {
    index: false,
    maxAge: "1y"
  },
  fallback: {
    dist: {},
    static: {
      skipUnknown: true,
      handlers: {
        ".htm": false,
        ".html": false
      }
    }
  }
};

const router = {
  mode: "history",
  base: {
    $resolve: (val = "/") => withTrailingSlash(normalizeURL(val))
  },
  _routerBaseSpecified: {
    $resolve: (_val, get) => typeof get("router.base") === "string"
  },
  routes: [],
  routeNameSplitter: "-",
  middleware: {
    $resolve: (val) => Array.isArray(val) ? val : [val].filter(Boolean)
  },
  linkActiveClass: "nuxt-link-active",
  linkExactActiveClass: "nuxt-link-exact-active",
  linkPrefetchedClass: false,
  extendRoutes: null,
  scrollBehavior: {
    $schema: {
      deprecated: "router.scrollBehavior` property is deprecated in favor of using `~/app/router.scrollBehavior.js` file, learn more: https://nuxtjs.org/api/configuration-router#scrollbehavior"
    }
  },
  parseQuery: false,
  stringifyQuery: false,
  fallback: false,
  prefetchLinks: true,
  prefetchPayloads: true,
  trailingSlash: void 0
};

const server = {
  https: false,
  port: process.env.NUXT_PORT || process.env.PORT || process.env.npm_package_config_nuxt_port || 3e3,
  host: process.env.NUXT_HOST || process.env.HOST || process.env.npm_package_config_nuxt_host || "localhost",
  socket: process.env.UNIX_SOCKET || process.env.npm_package_config_unix_socket,
  timing: (val) => val ? { total: true, ...val } : false
};

const cli = {
  badgeMessages: [],
  bannerColor: "green"
};

const generate = {
  dir: {
    $resolve: (val = "dist", get) => resolve(get("rootDir"), val)
  },
  routes: [],
  exclude: [],
  concurrency: 500,
  interval: 0,
  subFolders: true,
  fallback: { $resolve: (val) => val === true ? "400.html" : val || "200.html" },
  crawler: true,
  manifest: true,
  nojekyll: true,
  cache: {
    ignore: [],
    globbyOptions: {
      gitignore: true
    }
  },
  staticAssets: {
    dir: "static",
    base: { $resolve: (val, get) => val || joinURL(get("app.assetsPath"), get("generate.dir")) },
    versionBase: { $resolve: (val, get) => val || joinURL(get("generate.base"), get("generate.version")) },
    version: { $resolve: (val) => val || String(Math.round(Date.now() / 1e3)) }
  }
};

const nuxtConfigSchema = {
  ..._app,
  ..._common,
  ..._internal,
  build,
  messages,
  render,
  router,
  server,
  cli,
  generate
};

async function loadEnv(rootDir, options = {}) {
  const targetEnv = options.env ?? process.env;
  const env = await loadDotenv({
    rootDir,
    dotenvFile: options.dotenv ?? ".env",
    env: targetEnv,
    expand: options.expand ?? true
  });
  for (const key in env) {
    if (!key.startsWith("_") && targetEnv[key] === void 0) {
      targetEnv[key] = env[key];
    }
  }
}
async function loadDotenv(opts) {
  if (!opts.dotenvFile) {
    return;
  }
  const env = Object.create(null);
  const dotenvFile = resolve(opts.rootDir, opts.dotenvFile);
  if (existsSync(dotenvFile)) {
    const parsed = dotenv.parse(await promises.readFile(dotenvFile, "utf-8"));
    Object.assign(env, parsed);
  }
  if (!opts.env._applied) {
    Object.assign(env, opts.env);
    env._applied = true;
  }
  if (opts.expand) {
    expand(env);
  }
  return env;
}
function expand(target, source = {}, parse = (v) => v) {
  function getValue(key) {
    return source[key] !== void 0 ? source[key] : target[key];
  }
  function interpolate(value, parents = []) {
    if (typeof value !== "string") {
      return value;
    }
    const matches = value.match(/(.?\${?(?:[a-zA-Z0-9_:]+)?}?)/g) || [];
    return parse(matches.reduce((newValue, match) => {
      const parts = /(.?)\${?([a-zA-Z0-9_:]+)?}?/g.exec(match);
      const prefix = parts[1];
      let value2, replacePart;
      if (prefix === "\\") {
        replacePart = parts[0];
        value2 = replacePart.replace("\\$", "$");
      } else {
        const key = parts[2];
        replacePart = parts[0].substring(prefix.length);
        if (parents.includes(key)) {
          console.warn(`Please avoid recursive environment variables ( loop: ${parents.join(" > ")} > ${key} )`);
          return "";
        }
        value2 = getValue(key);
        value2 = interpolate(value2, [...parents, key]);
      }
      return value2 !== void 0 ? newValue.replace(replacePart, value2) : newValue;
    }, value));
  }
  for (const key in target) {
    target[key] = interpolate(getValue(key));
  }
}

async function loadNuxtConfig(opts) {
  const rootDir = resolve(process.cwd(), opts.rootDir || ".");
  await loadEnv(rootDir, opts.envConfig);
  const nuxtConfigFile = tryResolveModule(resolve(rootDir, opts.configFile || "nuxt.config"));
  let nuxtConfig = {};
  if (nuxtConfigFile && existsSync(nuxtConfigFile)) {
    nuxtConfig = requireModule(nuxtConfigFile, { clearCache: true });
    if (typeof nuxtConfig === "function") {
      nuxtConfig = await nuxtConfig(opts);
    }
    nuxtConfig = { ...nuxtConfig };
    nuxtConfig._nuxtConfigFile = nuxtConfigFile;
    nuxtConfig._nuxtConfigFiles = Array.from(scanRequireTree(nuxtConfigFile));
  }
  nuxtConfig = defu(opts.config, nuxtConfig, rc.read({ name: ".nuxtrc", dir: rootDir }), rc.readUser(".nuxtrc"));
  if (!nuxtConfig.rootDir) {
    nuxtConfig.rootDir = rootDir;
  }
  return applyDefaults(nuxtConfigSchema, nuxtConfig);
}

const nuxtCtx = getContext("nuxt");
const useNuxt = nuxtCtx.use;
async function loadNuxt(opts) {
  const resolveOpts = { paths: opts.rootDir };
  const nearestNuxtPkg = await Promise.all(["nuxt3", "nuxt-edge", "nuxt"].map((pkg2) => resolvePackageJSON(pkg2, { url: opts.rootDir }).catch(() => null))).then((r) => r.filter(Boolean).sort((a, b) => b.length - a.length)[0]);
  if (!nearestNuxtPkg) {
    throw new Error(`Cannot find any nuxt version from ${opts.rootDir}`);
  }
  const pkg = await readPackageJSON(nearestNuxtPkg);
  const majorVersion = parseInt((pkg.version || "").split(".")[0]);
  if (majorVersion === 3) {
    const { loadNuxt: loadNuxt3 } = await importModule("nuxt3", resolveOpts);
    const nuxt2 = await loadNuxt3(opts);
    return nuxt2;
  }
  const { loadNuxt: loadNuxt2 } = await tryImportModule("nuxt-edge", resolveOpts) || await importModule("nuxt", resolveOpts);
  const nuxt = await loadNuxt2({
    rootDir: opts.rootDir,
    for: opts.dev ? "dev" : "build",
    configOverrides: opts.config,
    ready: opts.ready,
    envConfig: opts.envConfig
  });
  return nuxt;
}
async function buildNuxt(nuxt) {
  const resolveOpts = { paths: nuxt.options.rootDir };
  if (nuxt.options._majorVersion === 3) {
    const { build: build2 } = await importModule("nuxt3", resolveOpts);
    return build2(nuxt);
  }
  const { build } = await tryImportModule("nuxt-edge", resolveOpts) || await tryImportModule("nuxt", resolveOpts);
  return build(nuxt);
}

function chainFn(base, fn) {
  if (typeof fn !== "function") {
    return base;
  }
  return function(...args) {
    if (typeof base !== "function") {
      return fn.apply(this, args);
    }
    let baseResult = base.apply(this, args);
    if (baseResult === void 0) {
      [baseResult] = args;
    }
    const fnResult = fn.call(this, baseResult, ...Array.prototype.slice.call(args, 1));
    if (fnResult === void 0) {
      return baseResult;
    }
    return fnResult;
  };
}

function resolvePath(path, opts = {}) {
  if (existsSyncSensitive(path)) {
    return path;
  }
  let resolvedPath;
  if (opts.alias) {
    resolvedPath = resolveAlias(path, opts.alias);
  }
  resolvedPath = resolve(opts.base || ".", resolvedPath);
  const resolvedPathFiles = readdirSync(dirname(resolvedPath));
  let isDirectory = false;
  if (existsSyncSensitive(resolvedPath, resolvedPathFiles)) {
    isDirectory = lstatSync(resolvedPath).isDirectory();
    if (!isDirectory) {
      return resolvedPath;
    }
  }
  for (const ext of opts.extensions) {
    const resolvedPathwithExt = resolvedPath + ext;
    if (!isDirectory && existsSyncSensitive(resolvedPathwithExt, resolvedPathFiles)) {
      return resolvedPathwithExt;
    }
    const resolvedPathwithIndex = join(resolvedPath, "index" + ext);
    if (isDirectory && existsSyncSensitive(resolvedPathwithIndex)) {
      return resolvedPathwithIndex;
    }
  }
  if (isDirectory) {
    return resolvedPath;
  }
  throw new Error(`Cannot resolve "${path}" from "${resolvedPath}"`);
}
function existsSyncSensitive(path, files) {
  if (!existsSync(path)) {
    return false;
  }
  const _files = files || readdirSync(dirname(path));
  return _files.includes(basename(path));
}
function resolveAlias(path, alias) {
  for (const key in alias) {
    if (key === "@") {
      continue;
    }
    if (path.startsWith(key)) {
      path = alias[key] + path.substr(key.length);
    }
  }
  return path;
}
function tryResolvePath(path, opts = {}) {
  try {
    return resolvePath(path, opts);
  } catch (e) {
  }
}
async function resolveFiles(path, pattern) {
  const files = await globby(pattern, {
    cwd: path,
    followSymbolicLinks: true
  });
  return files.map((p) => resolve(path, p));
}

function addTemplate(_template) {
  const nuxt = useNuxt();
  const template = normalizeTemplate(_template);
  nuxt.options.build.templates = nuxt.options.build.templates.filter((p) => normalizeTemplate(p).filename !== template.filename);
  nuxt.options.build.templates.push(template);
  return template;
}
function normalizeTemplate(template) {
  if (!template) {
    throw new Error("Invalid template: " + JSON.stringify(template));
  }
  if (typeof template === "string") {
    template = { src: template };
  } else {
    template = { ...template };
  }
  if (template.src) {
    if (!existsSync(template.src)) {
      throw new Error("Template not found: " + template.src);
    }
    if (!template.filename) {
      const srcPath = parse(template.src);
      template.filename = template.fileName || `${basename(srcPath.dir)}.${srcPath.name}.${hash(template.src)}${srcPath.ext}`;
    }
  }
  if (!template.src && !template.getContents) {
    throw new Error("Invalid template. Either getContents or src options should be provided: " + JSON.stringify(template));
  }
  if (!template.filename) {
    throw new Error("Invalid template. Either filename should be provided: " + JSON.stringify(template));
  }
  if (!template.dst) {
    const nuxt = useNuxt();
    template.dst = resolve(nuxt.options.buildDir, template.filename);
  }
  return template;
}
function normalizePlugin(plugin) {
  if (typeof plugin === "string") {
    plugin = { src: plugin };
  } else {
    plugin = { ...plugin };
  }
  if (!plugin.src) {
    throw new Error("Invalid plugin. src option is required: " + JSON.stringify(plugin));
  }
  plugin.src = normalize(plugin.src);
  if (plugin.ssr) {
    plugin.mode = "server";
  }
  if (!plugin.mode) {
    const [, mode = "all"] = plugin.src.match(/\.(server|client)(\.\w+)*$/) || [];
    plugin.mode = mode;
  }
  return plugin;
}
function addPlugin(_plugin, opts = {}) {
  const nuxt = useNuxt();
  const plugin = normalizePlugin(_plugin);
  nuxt.options.plugins = nuxt.options.plugins.filter((p) => normalizePlugin(p).src !== plugin.src);
  nuxt.options.plugins[opts.append ? "push" : "unshift"](plugin);
  return plugin;
}
function addPluginTemplate(plugin, opts = {}) {
  if (typeof plugin === "string") {
    plugin = { src: plugin };
  }
  plugin.src = addTemplate(plugin).dst;
  return addPlugin(plugin, opts);
}
function addServerMiddleware(middleware) {
  useNuxt().options.serverMiddleware.push(middleware);
}
function extendWebpackConfig(fn, options = {}) {
  const nuxt = useNuxt();
  if (options.dev === false && nuxt.options.dev) {
    return;
  }
  if (options.build === false && nuxt.options.build) {
    return;
  }
  nuxt.hook("webpack:config", (configs) => {
    if (options.server !== false) {
      const config = configs.find((i) => i.name === "server");
      if (config) {
        fn(config);
      }
    }
    if (options.client !== false) {
      const config = configs.find((i) => i.name === "client");
      if (config) {
        fn(config);
      }
    }
    if (options.modern !== false) {
      const config = configs.find((i) => i.name === "modern");
      if (config) {
        fn(config);
      }
    }
  });
}
function extendViteConfig(fn, options = {}) {
  const nuxt = useNuxt();
  if (options.dev === false && nuxt.options.dev) {
    return;
  }
  if (options.build === false && nuxt.options.build) {
    return;
  }
  nuxt.hook("vite:extend", ({ config }) => fn(config));
}
function addWebpackPlugin(plugin, options) {
  extendWebpackConfig((config) => {
    config.plugins = config.plugins || [];
    config.plugins.push(plugin);
  }, options);
}
function addVitePlugin(plugin, options) {
  extendViteConfig((config) => {
    config.plugins = config.plugins || [];
    config.plugins.push(plugin);
  }, options);
}
async function compileTemplate(template, ctx) {
  const data = { ...ctx, options: template.options };
  if (template.src) {
    try {
      const srcContents = await promises.readFile(template.src, "utf-8");
      return lodashTemplate(srcContents, {})(data);
    } catch (err) {
      console.error("Error compiling template: ", template);
      throw err;
    }
  }
  if (template.getContents) {
    return template.getContents(data);
  }
  throw new Error("Invalid template: " + JSON.stringify(template));
}
function addComponentsDir(dir) {
  const nuxt = useNuxt();
  ensureNuxtCompatibility({ nuxt: ">=2.13" }, nuxt);
  nuxt.options.components = nuxt.options.components || [];
  nuxt.hook("components:dirs", (dirs) => {
    dirs.push(dir);
  });
}
function addComponent(opts) {
  const nuxt = useNuxt();
  ensureNuxtCompatibility({ nuxt: ">=2.13" }, nuxt);
  nuxt.options.components = nuxt.options.components || [];
  const component = {
    export: opts.export || "default",
    chunkName: "components/" + kebabCase(opts.name),
    global: opts.global ?? false,
    kebabName: kebabCase(opts.name || ""),
    pascalName: pascalCase(opts.name || ""),
    prefetch: false,
    preload: false,
    shortPath: opts.filePath,
    async: false,
    level: 0,
    asyncImport: `() => import('${opts.filePath}').then(r => r['${opts.export || "default"}'])`,
    import: `require('${opts.filePath}')['${opts.export || "default"}']`,
    ...opts
  };
  nuxt.hook("components:extend", (components) => {
    const existingComponent = components.find((c) => c.pascalName === component.pascalName || c.kebabName === component.kebabName);
    if (existingComponent) {
      const name = existingComponent.pascalName || existingComponent.kebabName;
      console.warn(`Overriding ${name} component.`);
      Object.assign(existingComponent, component);
    } else {
      components.push(component);
    }
  });
}
function extendPages(cb) {
  const nuxt = useNuxt();
  nuxt.hook("pages:extend", cb);
}
const serialize = (data) => JSON.stringify(data, null, 2).replace(/"{(.+)}"/g, "$1");
const importName = (src) => `${camelCase(basename(src, extname(src))).replace(/[^a-zA-Z?\d\s:]/g, "")}_${hash(src)}`;
const importSources = (sources, { lazy = false } = {}) => {
  if (!Array.isArray(sources)) {
    sources = [sources];
  }
  return sources.map((src) => {
    if (lazy) {
      return `const ${importName(src)} = () => import('${src}' /* webpackChunkName: '${src}' */)`;
    }
    return `import ${importName(src)} from '${src}'`;
  }).join("\n");
};
const templateUtils = {
  serialize,
  importName,
  importSources
};
function isNuxt2(nuxt = useNuxt()) {
  return getNuxtVersion(nuxt).startsWith("2.");
}
function isNuxt3(nuxt = useNuxt()) {
  return getNuxtVersion(nuxt).startsWith("3.");
}
function getNuxtVersion(nuxt = useNuxt()) {
  const version = (nuxt?._version || nuxt?.version || nuxt?.constructor?.version || "").replace(/^v/g, "");
  if (!version) {
    throw new Error("Cannot determine nuxt version! Is currect instance passed?");
  }
  return version;
}
function checkNuxtCompatibilityIssues(constraints, nuxt = useNuxt()) {
  const issues = [];
  if (constraints.nuxt) {
    const nuxtVersion = getNuxtVersion(nuxt);
    const nuxtSemanticVersion = nuxtVersion.split("-").shift();
    if (!satisfies(nuxtSemanticVersion, constraints.nuxt)) {
      issues.push({
        name: "nuxt",
        message: `Nuxt version \`${constraints.nuxt}\` is required but currently using \`${nuxtVersion}\``
      });
    }
  }
  issues.toString = () => issues.map((issue) => ` - [${issue.name}] ${issue.message}`).join("\n");
  return issues;
}
function ensureNuxtCompatibility(constraints, nuxt = useNuxt()) {
  const issues = checkNuxtCompatibilityIssues(constraints, nuxt);
  if (issues.length) {
    throw new Error("Nuxt compatibility issues found:\n" + issues.toString());
  }
  return true;
}
function hasNuxtCompatibility(constraints, nuxt = useNuxt()) {
  return !checkNuxtCompatibilityIssues(constraints, nuxt).length;
}

function defineNuxtModule(input) {
  let mod;
  function wrappedModule(inlineOptions) {
    const nuxt = this.nuxt || useNuxt();
    if (typeof input === "function") {
      mod = input(nuxt);
    } else {
      mod = input;
    }
    if (mod.hooks) {
      nuxt.hooks.addHooks(mod.hooks);
    }
    if (typeof mod.setup !== "function") {
      return;
    }
    if (mod.requires) {
      const issues = checkNuxtCompatibilityIssues(mod.requires, nuxt);
      if (issues.length) {
        consola.warn(`Module \`${mod.name}\` is disabled due to incompatibility issues:
${issues.toString()}`);
        return;
      }
    }
    const configKey = mod.configKey || mod.name;
    const userOptions = defu(inlineOptions, nuxt.options[configKey]);
    const resolvedOptions = applyDefaults(mod.defaults, userOptions);
    if (!nuxtCtx.use()) {
      nuxtCtx.set(nuxt);
      if (!nuxt.__nuxtkit_close__) {
        nuxt.hook("close", () => nuxtCtx.unset());
        nuxt.__nuxtkit_close__ = true;
      }
    }
    if (isNuxt2()) {
      let virtualTemplates;
      nuxt.hook("builder:prepared", (_builder, buildOptions) => {
        virtualTemplates = [];
        buildOptions.templates.forEach((template, index, arr) => {
          if (!template.getContents) {
            return;
          }
          arr.splice(index, 1);
          virtualTemplates.push(template);
        });
      });
      nuxt.hook("build:templates", async (templates) => {
        const context = {
          nuxt,
          utils: templateUtils,
          app: {
            dir: nuxt.options.srcDir,
            extensions: nuxt.options.extensions,
            plugins: nuxt.options.plugins,
            templates: [
              ...templates.templatesFiles,
              ...virtualTemplates
            ],
            templateVars: templates.templateVars
          }
        };
        for await (const template of virtualTemplates) {
          const contents = await compileTemplate({ ...template, src: "" }, context);
          await promises.mkdir(dirname(template.dst), { recursive: true });
          await promises.writeFile(template.dst, contents);
        }
      });
    }
    return mod.setup.call(null, resolvedOptions, nuxt);
  }
  wrappedModule.meta = mod;
  return wrappedModule;
}

async function installModule(nuxt, installOpts) {
  let src;
  let options = {};
  const meta = {};
  if (typeof installOpts === "string") {
    src = installOpts;
  } else if (Array.isArray(installOpts)) {
    [src, options] = installOpts;
  } else if (typeof installOpts === "object") {
    if (installOpts.src || installOpts.handler) {
      src = installOpts.src || installOpts.handler;
      options = installOpts.options;
      Object.assign(meta, installOpts.meta);
    } else {
      src = installOpts;
    }
  } else {
    src = installOpts;
  }
  let handler;
  if (typeof src === "string") {
    const _src = resolveModule(resolveAlias(src, nuxt.options.alias), { paths: nuxt.options.modulesDir });
    const isESM = _src.endsWith(".mjs") || meta.isESM;
    handler = isESM ? await importModule(_src) : requireModule(_src);
    if (!meta.name) {
      meta.name = src;
    }
  } else if (typeof src === "function") {
    handler = src;
  } else {
    handler = defineNuxtModule(src);
  }
  if (handler.meta) {
    Object.assign(meta, handler.meta);
  }
  if (typeof meta.name === "string") {
    nuxt.options._requiredModules = nuxt.options._requiredModules || {};
    if (nuxt.options._requiredModules[meta.name]) {
      return;
    }
    nuxt.options._requiredModules[meta.name] = true;
  }
  const container = createModuleContainer(nuxt);
  await handler.call(container, options);
}

function createModuleContainer(nuxt) {
  return {
    nuxt,
    options: nuxt.options,
    ready() {
      return Promise.resolve();
    },
    addVendor() {
      console.warn("addVendor has been deprecated and has no effect.");
    },
    addTemplate(template) {
      if (typeof template === "string") {
        template = { src: template };
      }
      if (template.write === void 0) {
        template.write = true;
      }
      return addTemplate(template);
    },
    addPlugin(pluginTemplate) {
      return addPluginTemplate(pluginTemplate);
    },
    addLayout(tmpl, name) {
      const { filename, src } = addTemplate(tmpl);
      const layoutName = name || parse(src).name;
      const layout = nuxt.options.layouts[layoutName];
      if (layout) {
        consola.warn(`Duplicate layout registration, "${layoutName}" has been registered as "${layout}"`);
      }
      nuxt.options.layouts[layoutName] = `./${filename}`;
      if (name === "error") {
        this.addErrorLayout(filename);
      }
    },
    addErrorLayout(dst) {
      const relativeBuildDir = relative(nuxt.options.rootDir, nuxt.options.buildDir);
      nuxt.options.ErrorPage = `~/${relativeBuildDir}/${dst}`;
    },
    addServerMiddleware,
    extendBuild(fn) {
      nuxt.options.build.extend = chainFn(nuxt.options.build.extend, fn);
    },
    extendRoutes(fn) {
      extendPages((routes) => fn(routes, resolveAlias));
    },
    requireModule: installModule,
    addModule: installModule
  };
}

export { addComponent, addComponentsDir, addPlugin, addPluginTemplate, addServerMiddleware, addTemplate, addVitePlugin, addWebpackPlugin, buildNuxt, checkNuxtCompatibilityIssues, clearRequireCache, compileTemplate, createModuleContainer, defineNuxtModule, ensureNuxtCompatibility, extendPages, extendViteConfig, extendWebpackConfig, getNuxtVersion, getRequireCacheItem, hasNuxtCompatibility, importModule, installModule, isNodeModules, isNuxt2, isNuxt3, loadDotenv, loadEnv, loadNuxt, loadNuxtConfig, normalizePlugin, normalizeTemplate, nuxtCtx, requireModule, requireModulePkg, resolveAlias, resolveFiles, resolveModule, scanRequireTree, templateUtils, tryImportModule, tryRequireModule, tryResolveModule, tryResolvePath, useNuxt };
