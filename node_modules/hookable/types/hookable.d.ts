declare type HookCallback = (...args: any) => Promise<void> | void;
interface Hooks {
    [key: string]: HookCallback;
}
declare type HookKeys<T> = keyof T & string;
declare type NestedHooks<T> = {
    [name in HookKeys<T>]: NestedHooks<T> | HookCallback;
};
declare type DeprecatedHook<T> = string | {
    message: string;
    to: HookKeys<T>;
};
declare type DeprecatedHooks<T> = {
    [name in HookKeys<T>]: DeprecatedHook<T>;
};
interface LoggerT {
    error(...args: any): void;
    fatal?(...args: any): void;
    warn(...args: any): void;
}

declare function mergeHooks<T>(...hooks: NestedHooks<T>[]): T;

declare class Hookable<_HooksT = Record<string, HookCallback>, HooksT = _HooksT & {
    error: (error: Error | any) => void;
}, HookNameT extends HookKeys<HooksT> = HookKeys<HooksT>> {
    private _hooks;
    private _deprecatedHooks;
    private _logger;
    static mergeHooks: typeof mergeHooks;
    mergeHooks: typeof mergeHooks;
    constructor(logger?: LoggerT | false);
    hook<NameT extends HookNameT>(name: NameT, fn: HooksT[NameT] & HookCallback): () => void;
    hookOnce<NameT extends HookNameT>(name: NameT, fn: HooksT[NameT] & HookCallback): any;
    removeHook<NameT extends HookNameT>(name: NameT, fn: HooksT[NameT] & HookCallback): void;
    deprecateHook<NameT extends HookNameT>(name: NameT, deprecated: DeprecatedHook<HooksT>): void;
    deprecateHooks(deprecatedHooks: Record<HookNameT, DeprecatedHook<HooksT>>): void;
    addHooks(configHooks: NestedHooks<HooksT>): () => void;
    removeHooks(configHooks: NestedHooks<HooksT>): void;
    callHook<NameT extends HookNameT>(name: NameT, ...args: Parameters<HooksT[NameT]>): Promise<void>;
}

export { DeprecatedHook, DeprecatedHooks, HookCallback, HookKeys, Hooks, LoggerT, NestedHooks, Hookable as default };
