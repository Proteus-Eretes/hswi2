import { promises } from 'fs';
import { a as relative, j as join, r as resolve } from './index2.mjs';
import { g as getModulePaths, a as getNearestPackage, i as importModule } from './cjs.mjs';

const writeTypes = async (nuxt) => {
  const modulePaths = getModulePaths(nuxt.options.modulesDir);
  const tsConfig = {
    compilerOptions: {
      target: "ESNext",
      module: "ESNext",
      moduleResolution: "Node",
      skipLibCheck: true,
      strict: true,
      allowJs: true,
      noEmit: true,
      resolveJsonModule: true,
      allowSyntheticDefaultImports: true,
      types: ["node"],
      baseUrl: relative(nuxt.options.buildDir, nuxt.options.rootDir),
      paths: {}
    },
    include: [
      "./nuxt.d.ts",
      join(relative(nuxt.options.buildDir, nuxt.options.rootDir), "**/*"),
      ...nuxt.options.srcDir !== nuxt.options.rootDir ? [join(relative(nuxt.options.buildDir, nuxt.options.srcDir), "**/*")] : []
    ]
  };
  const aliases = {
    ...nuxt.options.alias,
    "#build": nuxt.options.buildDir,
    "#config": "@nuxt/nitro",
    "#storage": "@nuxt/nitro",
    "#assets": "@nuxt/nitro"
  };
  for (const alias in aliases) {
    const relativePath = relative(nuxt.options.rootDir, aliases[alias]).replace(/(?<=\w)\.\w+$/g, "") || ".";
    tsConfig.compilerOptions.paths[alias] = [relativePath];
    try {
      const { isDirectory } = await promises.stat(resolve(nuxt.options.rootDir, relativePath));
      if (isDirectory) {
        tsConfig.compilerOptions.paths[`${alias}/*`] = [`${relativePath}/*`];
      }
    } catch {
    }
  }
  const references = [
    ...nuxt.options.buildModules,
    ...nuxt.options.modules,
    ...nuxt.options._modules
  ].filter((f) => typeof f === "string").map((id) => ({ types: getNearestPackage(id, modulePaths)?.name || id }));
  const declarations = [];
  await nuxt.callHook("builder:generateApp");
  await nuxt.callHook("prepare:types", { references, declarations, tsConfig });
  const declaration = [
    ...references.map((ref) => {
      if ("path" in ref) {
        ref.path = relative(nuxt.options.buildDir, ref.path);
      }
      return `/// <reference ${renderAttrs(ref)} />`;
    }),
    ...declarations,
    "",
    "export {}",
    ""
  ].join("\n");
  async function writeFile() {
    const GeneratedBy = "// Generated by nuxi";
    const tsConfigPath = resolve(nuxt.options.buildDir, "tsconfig.json");
    await promises.writeFile(tsConfigPath, GeneratedBy + "\n" + JSON.stringify(tsConfig, null, 2));
    const declarationPath = resolve(nuxt.options.buildDir, "nuxt.d.ts");
    await promises.writeFile(declarationPath, GeneratedBy + "\n" + declaration);
  }
  nuxt.hook("builder:prepared", writeFile);
  await writeFile();
};
function renderAttrs(obj) {
  return Object.entries(obj).map((e) => renderAttr(e[0], e[1])).join(" ");
}
function renderAttr(key, value) {
  return value ? `${key}="${value}"` : "";
}

const loadKit = async (rootDir) => {
  try {
    return await importModule("@nuxt/kit", rootDir);
  } catch (e) {
    if (e.toString().includes("Cannot find module '@nuxt/kit'")) {
      throw new Error("nuxi requires `@nuxt/kit` to be installed in your project. Try installing `nuxt3` or `@nuxt/bridge` first.");
    }
    throw e;
  }
};

export { loadKit as l, writeTypes as w };
